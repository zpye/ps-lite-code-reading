# 工作流程

这部分的内容是分析使用ps-lite时其内部的工作流程。

## 1. 开启和关闭

开启和关闭是每一个使用ps-lite的程序中必要的操作，例如样例文件**test_connection.cc**中，就只进行了Start和Finalize操作，中间不做任何事。

首先要说明的是，Start和Finalize操作都是定义在头文件**ps.h**中的，而且文件中的方法基本上都是Postoffice同名方法的简单封装。在程序运行的过程中，Postoffice一直都是以单例的形式存在的，用于处理当前程序(进程)所在节点的相关事务。

运行Start方法，需要传入一个Customer的id编号作为参数。开始时会根据系统环境变量进行初始化，通过"DMLC_NUM_WORKER"和"DMLC_NUM_SERVER"来获取工作节点和服务节点的数量，通过"DMLC_ROLE"获取自身节点的类型，通过"PS_VERBOSE"获取调试信息的等级。然后开启日志记录，并初始化节点信息，为特殊节点组(调度节点、全体工作节点、全体服务节点及它们的组合)生成组内包含的节点编号。前两步在一个进程中最多只会执行一次，之后如果反复调用Start方法的话也会跳过这两个步骤。

下一步是调用Van的Start方法，并将Customer的id编号作为参数传入。这一步的主要目的是为自身节点绑定ip地址和端口，并将自身节点的信息发送给调度节点，用于将自身添加到整个系统中。调度节点的ip地址和端口由"DMLC_PS_ROOT_URI"和"DMLC_PS_ROOT_PORT"这两个环境变量给出。另外，所有非调度节点都会开启"心跳"线程，每间隔一段时间向调度节点报告自身情况，用于检查节点失效的情况。

最后一步是根据设置对所有节点调用屏障方法，等待所有节点都完成Start方法后才可以执行后面的操作。

Finalize方法会先根据设置对所有节点执行屏障操作，保证所有节点都正在执行Finalize方法。然后清除和销毁自身的相关变量，最后如果注册了回调方法则调用。

这部分的Customer编号主要起到了标记的作用，并没有真正创建一个Customer对象，目的是为了使系统的各个节点之间都能够知道其他节点的存在。程序中要求至少要存在id编号为0的一次初始化，而且在退出时Postoffice只允许id编号为0的调用进入到销毁和释放资源阶段。

## 2. 发送和接收消息

消息的收发可以参考样例文件**test_simple_app.cc**，通过SimpleApp封装了一个简单的通信接口，内部创建了一个Customer对象来不断接收消息和跟踪请求。

发送方的流程是创建一个消息(Message)对象，填充相关的信息，调用Postoffice中的Van对象发送。发送消息之前会使用Customer对象根据发送的节点或节点组的id添加一个新的请求，开始跟踪该请求的响应，调用wait可以等待该请求完成。

接收方的流程是创建一个消息(Message)对象，将响应的内容填充进去，调用Postoffice中的Van对象发送。与发送不同的是，不需要跟踪响应的情况，而且消息中的请求属性要置为false。

## 3. 推送和拉取

推送和拉取可以参考样例文件test_kv_app.cc和/test_kv_app_multi_workers.cc。KVWorker和KVServer均继承于SimpleApp，实现了更高层次的通讯接口。

推送和拉取的操作均需要提供KVPairs中的内容作为参数，其中keys会关联指定的数据，也会影响切片后发送到哪一个Server上。这两个操作都是异步的，需要使用Wait方法来等待完成。