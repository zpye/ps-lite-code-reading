# 功能模块

## message.h

### 1. Node

Node表示一个节点包含的信息。包括：

类型(Role)，可以为Server、Worker、Scheduler其中的一种；

节点的id编号以及所属Customer的id编号；

主机名或IP地址，以及绑定的端口；

### 2. Control

Control表示系统控制信息的元数据。包括：

命令(Command)，可以为EMPTY、TERMINATE、ADD_NODE、BARRIER、ACK、HEARTBEAT中的一种；

若干Node，表示指令作用于这些节点；

barrier_group，表示需要使用屏障来同步的节点，它的值为待同步节点所在的组；

### 3. Meta

Meta表示Message的元数据。包括：

数据头和数据体；

时间戳；

应用(App)的id编号、Customer的id编号、发送者的节点id编号、接收者的节点id编号；

是否为请求Message的标记、是否为推送Message的标记、是否用于SimpleApp的标记；

系统控制信息(Control)；

Message中每项数据的数据类型；

### 4. Message

Message用于节点之间的通信。包括：

元数据(Meta)；

若干项大段数据，每项数据都使用SArray存储；

## sarray.h

### SArray

SArray是一种用于共享的数组结构，功能上类似于vector容器，内部的数据使用智能指针(shared_ptr)进行引用计数，当引用计数减少到0时，释放数组占用的内存空间；

## customer.h & customer.cc

### Customer

Customer的主要功能是作为通信的目标，接收并处理消息(Message)。在Customer初始化时，会创建一个线程安全的消息队列，同时开启一个线程不断循环从队列中取出消息，使用外部定义的方法处理消息；

Customer的另一个功能是追踪请求的响应。添加一个请求时，会记录节点组中节点的个数和当前时间戳，之后每处理一条消息，只要消息的类型不是请求，就会将对应时间戳的实际接收数量自增1。如果需要等待某个时间戳的请求结束，系统会判断接收到的消息数量是否等于节点的数量，相等时才能认为请求结束；

## resender.h

### Resender

Resender的主要功能是在指定时间内没有收到回复消息时重新发送消息。Resender在初始化时会指定超时等待的时长、重新发送的次数和Van对象的指针，然后开启监控线程；

Resender内部有一个存放已发送消息的记录，每条记录包含了消息、等待时间以及已重发次数。当有消息发送时，外部会调用方法添加一条记录；当接收一条回复消息(ACK)时，则从记录中删除对应消息；当接收到一条普通消息时，则会发送对应的回复消息；

监控线程的主要工作就是不断查看已发送消息的记录，如果超过等待时间且在最大尝试次数之内，则会再次发送该消息；

## van.h & van.cc

### Van

Van的主要功能是向远程的节点发送和接收消息，依赖于具体的实现，如socket或zmq等；

开启Van时，会进行一系列初始化工作。初始化可以分为三个阶段：第一阶段是初始化节点信息、绑定端口、连接调度节点、开启接收线程，该部分的值基本上都是来自于环境变量和外部输入；第二阶段是向调度节点发送信息，使调度节点知道自己的节点，除非自己的节点就是调度节点；第三阶段是设置定时重发，并且开启心跳线程用于检测失败。第一阶段和第三阶段被设置为只能按照顺序执行一次。

接收线程的主要工作是在接收到一条消息后，首先且累加接收到的数据大小，然后在Resender中添加接收消息，最后如果消息的Control类型不为空，则根据Control的命令类型分别调用对应的处理方法，否则按照数据消息处理；

处理消息的方法包括：

添加节点(ADD_NODE)：首先更新本地节点，使其与消息中的节点信息保持一致，另外如果存在长时间无响应死节点，会利用消息中的节点信息恢复死节点；接下来会逐个连接消息中包含的节点，并更新映射关系和计数。
当本地节点为调度节点(Scheduler)时，会不断接收其他节点上报给自己的消息，直到接收到消息的节点数量与Postoffice中预设的节点数量一致时，开始根据ip地址和端口号对节点进行排序，逐个为节点赋予服务节点(Server)或工作节点(Worker)的id号，连接节点并更新“心跳”时间；如果节点已经连接，则为其增加一个新的id映射。当这些操作完成后，会将本地节点(Scheduler)的信息加入到这些节点中，并发送给所有新添加连接的节点，消息类型为ADD_NODE。另外，当接收到消息的节点数量与Postoffice中预设的节点数量不一致时，会检查是否存在需要恢复的节点。除了对死节点不发送消息外，会将只包含恢复节点的消息发送给活动节点，并将包含全部节点的消息发送给恢复节点。

当Control的命令为终止(TERMINATE)时，会将Van的ready状态置为false，阻止其更新节点和发送消息，然后退出接收消息线程的主循环，最终结束该线程。

当Control的命令为屏障(BARRIER)时，若消息同时满足请求属性为true，首先要保证屏障计数器的容器不为空，然后将容器中对应屏障组(barrier_group)的计数加1，当计数与屏障组中节点数量一致时，重置该组的计数器，并向该组中的节点发送消息，消息的命令类型为BARRIER，请求类型为false，app_id和customer_id与接收消息相同；若消息的请求属性为false，则交给Postoffice处理，用于解除屏障。

当Control的命令为“心跳”(HEARTBEAT)时，首先在Postoffice中对消息中包含的节点更新“心跳”时间，然后如果本地节点为调度节点的话，还需要向这些节点发送“心跳”响应消息，命令类型为HEARTBEAT。

最后，如果消息中没有Control内容，则为普通数据消息，在Postoffice中通过app_id和customer_id找到对应的Customer对象，并将消息传递给该对象进行进一步处理。

Van类中还提供了将Meta内容转化为Protobuf类型和反向操作的方法。

## postoffice.h & postofice.cc

### Postoffice

Postoffice是一个单例类，与Node所在进程具有相同的生命周期，用于对节点进行管理。在初始化Postoffice类时，会同时创建一个Van对象，用于消息的发送和接收，一个Postoffice对象只包含一个Van对象。

开启Postoffice时，首先会从环境变量中获取并配置节点数量和节点类型等信息，然后生成工作节点(Worker)、服务节点(Server)和调度节点(Scheduler)的id号，最后开启Van，记录开启时间，并根据需要对全部节点进行一次屏障操作。退出时，首先根据需要对全部节点进行一次屏障操作，然后清理相关变量，最后如果注册了回调方法，则调用之。

Postoffice也提供了一些用于外部调用的方法，包括：

添加、删除和查询Customer。Customer在Postoffice中存储的方式使用了两个层次的索引，第一层是应用(App)的id编号，第二层是Customer的id编号，操作时需要先确定App，再确定Customer；

根据Customer的id编号和节点组编号进行一次屏障操作。首先验证节点组包含节点个数是否大于1，以及本地节点是否包含在节点组中，然后向调度节点发送一条消息，消息的Control命令为屏障(BARRIER)，请求属性为true，Customer的id编号与进入屏障的节点组编号都和传入参数相同，App编号为0，最后该方法通过条件变量的方式等待屏障解除；

处理解除屏障的消息。该方法只对Control命令为屏障(BARRIER)，且请求属性为false的消息响应，操作是将该消息目的App中的所有Customer统一解除屏障。除了App编号为0的那一组Customer，其余每个添加到Postoffice中的Customer最多只能进行一次屏障操作；

通过节点的顺序(rank)计算id编号。服务节点(Server)的编号为![$$rank\times2+8$$](http://latex.codecogs.com/gif.latex?rank\times2+8)，工作节点(Worker)的编号为![$$rank\times2+9$$](http://latex.codecogs.com/gif.latex?rank\times2+9)，也就是说这两种节点的编号是从8开始交替排列的。之所以从8开始是因为存在一些预先指定好的特殊节点(组)，其中调度节点编号为1，全部服务节点所在的组编号为2，全部工作节点所在的组编号为4，通过相加的方式可以得到两者或三者的组合，恰好对应了数字1到7。另外，如果要从编号反过来计算rank，则为![$$\lfloor(id-8)/2\rfloor$$](http://latex.codecogs.com/gif.latex?\\lfloor(id-8)/2\rfloor)；

更新“心跳”。将指定节点编号的“心跳”时间更新至指定时间；

获取节点组。根据节点编号返回该节点所在节点组的全部编号；

获取死亡节点。返回全部在指定时间内未响应“心跳”的节点编号。

## simple_app.h

### 1. SimpleData

SimpleData是一个结构体，表示SimpleApp接收到的请求或响应。SimpleData包含了发送者的节点编号、Customer编号、时间戳、数据头和数据体。

### 2. SimpleApp

SimpleApp是对通信过程的简单封装，使用者需要提供数据头和数据体，其中数据头是一个整数，数据体是字符串，这两项在元数据(Meta)中有对应的表示。SimpleApp对象包含的内容主要有一个Customer实例，以及处理request属性消息和非request属性消息的两个方法，这两个方法需要外部注册进来。

SimpleApp在内部封装了处理消息的方法Process，会根据消息的请求(request)属性进一步调用外部注册的处理方法，Process方法会在初始化SimpleApp时，用于生成一个新的Customer对象，来处理接收到的消息。

SimpleApp主要提供了3个调用接口，分别是请求、响应和等待。请求和响应都可以看作是发送消息，只是内容和目标不同，而且请求会通过Customer记录响应的数量，等待使用Customer来阻塞等待对应时间戳的请求已经接收到全部的响应。

## kv_app.h

### 1. KVPairs

KVPairs存储了键值对的列表。其中keys存储了唯一的且升序排列的键，lens存储了每个键对应值的个数，vals依次存储了这些值。

### 2. KVMeta

KVMeta是KV请求的元数据，类似于Message的Meta，里面存储了发送者的id号，Customer的id号，时间戳，命令以及是否为推送请求。

### 3. KVWorker

KVWorker继承自SimpleApp，是工作节点实现功能的主体，主要用法是从服务节点拉取数据，经过计算后将结果推送会服务节点。KVWorker最常用的两个操作就是拉取(Pull)和推送(Push)

拉取(Pull)操作首先会向服务节点组提出一个新的请求(request)并获得该请求的时间戳，然后注册一个回调函数用来处理对应时间戳的数据，最后将键值对中的键发送消息。

拉取操作中注册的回调函数，首先要检测接收到的键值对是否符合要求，包括每个KVPairs中工作节点keys的数量与接收到keys的数量是否一致，每个KVPairs中keys的数量与lens的数量是否一致，以及工作节点和接收到的所有KVPairs中keys数量总和是否一致；接下来要填充vals和lens的数据，也就是将发送过来的数据复制到一段连续的内存中；最后如果外部提供了额外的回调函数，则在末尾处调用。

推送(Push)操作首先向服务节点组提出一个新的请求(request)并获得该请求的时间戳，然后将准备好的keys，vals，lens放入到KVPair中并发送消息。

在KVWorker中无论是拉取操作还是推送操作，最后都会调用发送(Send)方法。

发送方法首先会对KVPairs进行切片，默认的切片方法需要传入一个KVPairs和一组范围，每个范围有一个起始位置和一个结束位置，而且要保证一个范围的结束位置就是下一个范围的起始位置。切片操作先是为每个范围(Range)找到KVPairs中keys的对应位置，具体来说就是在keys中确定一系列的位置，使得每两个相邻位置之间的keys值都在对应范围内。找到切分的位置后，需要把KVPairs中的keys，lens和vals按照位置划分成若干个小的KVPairs，并且根据其中是否存在keys来标记是否发送，最后将这些结果放入一个容器中(SlicedKVs)返回。

在得到完成切片的若干KVPairs之后，发送方法会按照切片依次向不同的服务节点发送消息，消息内容是对应切片的keys，vals和lens。

### 4. KVServer

KVServer继承自SimpleApp，是服务节点实现功能的主体，其功能基本上都属于被动调用，主要用于处理从工作节点发送过来的消息。

KVServer中用于处理消息的方法(Process)会用于初始化Customer，功能是不断接收消息并将其中的内容转化为KVMeta和KVPairs，最后调用外部注册进来的处理请求的方法进一步处理数据。

程序中提供的默认处理请求方法是根据KVMeta中的push属性，判定当前数据是从外部推送进来还是从内部拉取出去。如果属性为push，则在存储的值中找到键对应的值并累加；如果属性不为push，则将存储的值提取出来。最后会调用KVServer中的响应方法返回结果。

KVServer中的响应方法就是将响应的数据放到消息中，最后发送消息。